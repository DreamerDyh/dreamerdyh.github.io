<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>iOS动画进阶之路（一）和贝塞尔曲线一起玩 | 逐星</title><meta name="description"><meta name="generator" content="逐星"><meta name="author" content="Dai Yunhao"><meta name="keywords" content="iOS, 设计, 佛, 道"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/zxtitle.png" alt="逐星" title="逐星"></a><!--h1//a(href= config.root, alt= config.title, title= config.title, itemprop='headline')= config.title--><p itemprop="description">应无所住，而生其心。</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">iOS动画进阶之路（一）和贝塞尔曲线一起玩</h1><span class="post-meta">published on<time itemprop="datePublished" datetime="2017-06-01T01:52:49.000Z"> 2017-06-01 at 9:52</time><br>last updated on<time itemprop="dateModified" datetime="2017-06-01T01:52:49.000Z"> 2017-06-01 at 9:56</time></span><h1 id="0-写在开头的话"><a href="#0-写在开头的话" class="headerlink" title="0. 写在开头的话"></a>0. 写在开头的话</h1><p>动画，对于任何iOS应用来说，都是非常重要的东西。</p>
<p>恰当、优雅的动画，能让人感觉到美，感受到创作者的匠心。</p>
<p>那么，要如何才能实现一段相对高级的iOS动画呢？这显然是一个非常庞大，难以回答的问题。</p>
<p>本系列，将从一些粗浅的角度出发，对这个问题作部分回答。</p>
<p><em>本系列默认读者已经对iOS开发和基本的iOS动画开发有一定基础。</em></p>
<h1 id="1-和贝塞尔曲线一起玩"><a href="#1-和贝塞尔曲线一起玩" class="headerlink" title="1. 和贝塞尔曲线一起玩"></a>1. 和贝塞尔曲线一起玩</h1><p>贝塞尔曲线(Bézier curve)是计算机图形图像造型的基本工具，是成千上万由计算机创造的优美图形的源头，在iOS的动画开发中，贝塞尔曲线同样大有妙用。</p>
<p>这一章的主题，就是如何愉快地和贝塞尔曲线一起玩耍。</p>
<h2 id="1-1-贝塞尔曲线原理"><a href="#1-1-贝塞尔曲线原理" class="headerlink" title="1.1. 贝塞尔曲线原理"></a>1.1. 贝塞尔曲线原理</h2><blockquote>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_PierreBezier.jpg" alt=""></p>
<p>贝塞尔曲线是由法国数学家<strong>Pierre Bézier</strong>所发明，由此为计算机矢量图形学奠定了基础，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线的主要意义在于无论是直线或曲线都能在数学上予以描述。</p>
<p>引用自<a href="http://baike.baidu.com/link?url=6F62jSlKWDqDaJq2SYiV-1v4-lhhTbxrBxjoKm64aK5vDYA6bYmVeHnXBhkXH3o26vvd_cvCm9SMFwgf4XylL9F5v2Q37p4Gw2SM0teGdJAblxbstHilvYkBneshwp3_g0hFOZXboP6ppvj_dJSNLq" target="_blank" rel="external">贝塞尔曲线</a></p>
</blockquote>
<p><strong>数学原理</strong> : <em>给定n+1个数据点，p0(x0 , y0)  …  pn(xn , yn)，生成一条曲线，使得该曲线与这些点所连结的折线相近</em>。</p>
<p>当n = 1时，数据点个数为2，此时是一条直线，称为一次贝塞尔曲线。</p>
<p>当n＝2时，数据点个数为3，包括一个起点，一个终点，一个控制点，称为二次贝塞尔曲线。</p>
<p>以此类推，三次贝塞尔曲线，即一个起点，一个终点，两个控制点的情况，如下图所示：</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_power3BezierCurve.jpg" alt=""></p>
<p>对贝塞尔曲线，数学上有一个简单的理解即可，强烈推荐使用keynote、photoshop或sketch等软件内的曲线工具直观体验一下创造贝塞尔曲线的感觉。</p>
<p>在iOS开发中，我们主要利用<code>Core Graphics</code>提供的C API或<code>UIBezierPath</code>这个类来处理贝塞尔曲线，请自行学习相关API。</p>
<h2 id="1-2-运动轨迹"><a href="#1-2-运动轨迹" class="headerlink" title="1.2. 运动轨迹"></a>1.2. 运动轨迹</h2><blockquote>
<p>在iOS中，我们能够控制<code>Animatable</code>属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。</p>
<p>引用自<a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="external">iOS核心动画高级技巧</a></p>
</blockquote>
<p>正如引用所述，iOS为我们提供的框架使得我们可以轻易实现复杂的曲线运动。这需要用到贝塞尔曲线和<code>CAKeyframeAnimation</code>。</p>
<p>这里有一个demo演示了如何用贝塞尔曲线和<code>CAKeyframeAnimation</code>模拟纸飞机的运动轨迹，Demo地址<a href="https://github.com/DreamerDyh/DYHAnimationDemos" target="_blank" rel="external">DYHAnimationDemos</a>，选择Demo2-纸飞机。</p>
<p>进入demo，点击<code>起飞</code>，效果如下图所示：</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo02_01.gif" alt=""></p>
<p>可以看到，纸飞机沿着复杂的曲线飞行，并且在飞行的过程中不停的偏转角度。用常规思路去实现这个动画将会非常复杂，幸运的是我们有<code>CAKeyframeAnimation</code>。</p>
<p>首先我们创建一个path，就是预设好的飞行轨迹，本质上是一条贝塞尔曲线，建议大家使用<code>UIBezierPath</code>这个类来创建path，写起来比<code>Core Graphics</code>的API简单很多，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//飞行轨迹</div><div class="line">UIBezierPath *flyPath = [UIBezierPath bezierPath];</div><div class="line">[flyPath moveToPoint:airplaneImageView.center];</div><div class="line">[flyPath addCurveToPoint:CGPointMake(289.f, 63.f) controlPoint1:airplaneImageView.center controlPoint2:CGPointMake(498.f, 164.f)];</div><div class="line">...</div><div class="line">self.flyPath = flyPath;</div></pre></td></tr></table></figure>
<p>这些坐标值可以用sketch等设计软件进行估算，这需要你对贝塞尔曲线很熟悉，我们后面还会提到。</p>
<p><em>PS:这个Demo的数值主要针对4.7英寸设备适配，建议在4.7英寸设备或模拟器上运行。</em></p>
<p>有了飞行轨迹，我们只需利用<code>CAKeyframeAnimation</code>的特性就可以快速实现这个效果，最核心的动画代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CAKeyframeAnimation *flyAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">flyAnimation.path = self.flyPath.CGPath;</div><div class="line">flyAnimation.rotationMode = kCAAnimationRotateAuto;</div><div class="line">...</div><div class="line">[self.airplaneImageView.layer addAnimation:flyAnimation forKey:nil];</div></pre></td></tr></table></figure>
<p>可以看到，我们仅仅是简单的把预设好的path传递给动画实例，非常简单；一个值得注意的点是<code>flyAnimation.rotationMode = kCAAnimationRotateAuto;</code>这一行，这是Apple为我们提供的非常优秀的特性，只要设置为常量<code>kCAAnimationRotateAuto</code>，沿着path做动画的<code>Layer</code>将会根据path的切线自动旋转角度。我们令创建的path可视化，再感受一下纸飞机是怎样运动的。</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo02_02.gif" alt=""></p>
<h2 id="1-3-用贝塞尔曲线动态绘制不规则图形-液态菜单"><a href="#1-3-用贝塞尔曲线动态绘制不规则图形-液态菜单" class="headerlink" title="1.3. 用贝塞尔曲线动态绘制不规则图形 - 液态菜单"></a>1.3. 用贝塞尔曲线动态绘制不规则图形 - 液态菜单</h2><p><img src="http://op08ijx76.bkt.clouddn.com/animation1_liquidMenuBySoheilBehnezhadOnDribbble.gif" alt=""></p>
<p><strong>引用自<a href="https://dribbble.com/shots/2173582-Materials-In-Liquid-State" target="_blank" rel="external">Materials In Liquid State</a></strong></p>
<p>液态风格是Dribbble上非常流行的风格，有许多大神的UI设计都运用了这种风格，典型的液态风格大概就长上面这样，看起来挺炫酷的，那么我们来试着模仿一下这个动画吧！</p>
<p>仔细观察这个动画，不难发现，实现这个动画的关键是要实现这些小球之间的<code>粘连</code>效果，其他的动作都只是简单的变换。</p>
<p>这个粘连的效果是随着小球之间的相对位置不停地变化的，显然，小球每移动一点，我们就需要重绘一次粘连的部分。这里有两个问题需要解决，其一是如何触发重绘，其二是如何重绘。</p>
<p>要在动画过程中不停地触发重绘，很容易想到我们需要一个计时器，但是常用的<code>NSTimer</code>精度不够，我们需要用到<code>CADisplayLink</code>。</p>
<blockquote>
<p><code>CADisplayLink</code>是<code>Core Animation</code>提供的一个类似于<code>NSTimer</code>的类，它总是在屏幕刷新一次更新之前启动，它的接口设计的和<code>NSTimer</code>很类似，但是和<code>NSTimer</code>以秒为单位不同，<code>CADisplayLink</code>有一个整型的<code>frameInterval</code>属性，指定了间隔多少帧之后才执行，默认值是1，意味着每次屏幕刷新之前都会执行一次。这种高精度使得<code>CADisplayLink</code>非常适合用来做重绘工作。但即使<code>CADisplayLink</code>也不能<em>保证</em>每一帧的任务都按计划执行，一些失去控制的离散的任务或者事件可能会导致动画偶尔地丢帧。当使用<code>NSTimer</code>的时候，一旦有机会计时器就会开启，但是<code>CADisplayLink</code>却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>
<p>引用自<a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="external">iOS核心动画高级技巧</a></p>
</blockquote>
<p><code>CADisplayLink</code>的简单用法如下所示，runLoop mode的设置和<code>NSTimer</code>的类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)];</div><div class="line">[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div></pre></td></tr></table></figure>
<p>要绘制不规则的粘连部分，就需要用到我们这章的核心－<strong>贝塞尔曲线</strong>。相信大多数人都用过<code>Core Graphics</code>里的API，它们是一系列形如<code>CGPathMoveToPoint()</code>的C函数，这些API的本质就是在绘制贝塞尔曲线，但需要基于一个<code>图形上下文</code>。除了<code>Core Graphics</code>，我们还有另一种选择，<code>Core Animation</code>为我们准备的强大工具-<code>CAShapeLayer</code>。</p>
<blockquote>
<p><code>CAShapeLayer</code>是一个通过矢量图形而不是bitmap来绘制的<code>Layer</code>子类。你指定诸如<code>strokeColor</code>和<code>lineWidth</code>等属性，用<code>CGPath</code>来定义想要绘制的图形，然后<code>CAShapeLayer</code>就能自动渲染出来。相比<code>Core Graphics</code>，使用<code>CAShapeLayer</code>有以下一些优点：</p>
<ol>
<li>渲染快速。<code>CAShapeLayer</code>使用了硬件加速，绘制同一图形会比用<code>Core Graphics</code>快很多。</li>
<li>高效使用内存。一个<code>CAShapeLayer</code>不需要像普通<code>CALayer</code>一样创建一个<code>context</code>，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被<code>Layer</code>边界剪裁掉。一个<code>CAShapeLayer</code>可以在边界之外绘制。你的path不会像在使用<code>Core Graphics</code>的普通<code>CALayer</code>一样被剪裁掉。</li>
</ol>
<p>引用自<a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="external">iOS核心动画高级技巧</a></p>
</blockquote>
<p>确定了这两个要点，我最终的思路如下：</p>
<ol>
<li>定义一个代表单个小球的控件，它可以”吐出”一个小球，并且带有粘连效果</li>
<li>“吐出”小球的过程是一段位置变化的动画，利用<code>CADisplayLink</code>，在动画进行时触发重绘回调</li>
<li>在重绘回调中利用<code>CAShapeLayer</code>绘制贝塞尔曲线，模拟粘连形状</li>
<li>多个小球连续吐出，模仿图中的效果</li>
</ol>
<p>这个思路事实上不够好，很多地方实现得并不优雅，但是我们的核心是描述<strong>用贝塞尔曲线动态绘制不规则图形</strong>的情形，其他的部分，相信看这篇文章的你会有更好的思路。</p>
<p>Demo地址<a href="https://github.com/DreamerDyh/DYHAnimationDemos" target="_blank" rel="external">DYHAnimationDemos</a>，选择Demo3-液态菜单。</p>
<p>我们先来简单地过一下实现，首先我创建了<code>DYHLiquidView</code>，并提供了他的核心方法<code>-pushLiquidView:delay:translationY:completion:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)pushLiquidView:(DYHLiquidView *)view delay:(CGFloat)delay translationY:(CGFloat)translationY completion:(DYHLiquidViewCompletionBlock)completion</div><div class="line">&#123;</div><div class="line">...</div><div class="line">[self insertSubview:view belowSubview:self.contentView];</div><div class="line">...</div><div class="line">[self beforeAnimation];</div><div class="line">[UIView animateWithDuration:0.6f delay:delay usingSpringWithDamping:0.65f initialSpringVelocity:0.f options:0 animations:^&#123;</div><div class="line">view.center = CGPointMake(selfCenter.x, selfCenter.y + translationY);</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">if (finished) &#123;</div><div class="line">[self afterAnimation];</div><div class="line">...</div><div class="line">&#125;</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>事实上主要功能只是把待push的小球添加到自己的<code>contentView</code>上，并添加了一段第1章提过的spring动画，使待push的小球以弹性效果移动到屏幕上的指定位置。</p>
<p><code>-beforeAnimation</code>在移动动画开始前调用，这个方法内部会创建一个<code>CADisplayLink</code>，以defaultMode添加到runLoop，使得动画执行过程中能不断地触发重绘。</p>
<p><code>-afterAnimation</code>在移动动画完成后调用，这个方法内部会尝试注销<code>CADisplayLink</code>，即被“吐出”的小球到位后，无须再触发重绘了。</p>
<p>你可能注意到了<code>animationCount</code>这个属性，这是模仿ARC的思路设置的，这样在多个动画同时执行时确保<code>CADisplayLink</code>存在，虽然本质上在本demo中没有触发这个机制，但要处理面对多个动画时这确实非常有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)beforeAnimation</div><div class="line">&#123;</div><div class="line">if (!self.displayLink) &#123;</div><div class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkAction:)];</div><div class="line">[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line">self.animationCount ++;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)afterAnimation</div><div class="line">&#123;</div><div class="line">self.animationCount --;</div><div class="line">if (self.animationCount == 0) &#123;</div><div class="line">[self.displayLink invalidate];</div><div class="line">self.displayLink = nil;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了按帧触发的重绘回调，接下来我们就开始绘制粘连部分了。首先确定绘制的思路如下:</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_LiquidMind.png" alt=""></p>
<p>图中的蓝色小球就是本体，黄色小球就是被”吐出”的小球，要绘制粘连部分，我们需要确定贝塞尔曲线中的关键点，从图上不难看出，我们只需要知道<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>、<code>C1</code>这几个点的实时位置，再把这几个点用贝塞尔曲线连接起来，就是我们想要的粘连部分了。生成贝塞尔曲线的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (BOOL)drawLiquidFromCircle:(DYHCircle *)fromCircle toCircle:(DYHCircle *)toCircle onPath:(UIBezierPath *)path</div><div class="line">&#123;</div><div class="line">CGFloat x1 = fromCircle.center.x;</div><div class="line">CGFloat y1 = fromCircle.center.y;</div><div class="line">CGFloat r1 = fromCircle.radius;</div><div class="line">CGFloat x2 = toCircle.center.x;</div><div class="line">CGFloat y2 = toCircle.center.y;</div><div class="line">CGFloat r2 = toCircle.radius;</div><div class="line">if (x1 != x2) &#123;</div><div class="line">return NO;</div><div class="line">&#125;</div><div class="line">CGPoint pointA = CGPointMake(x1 - r1, y1);</div><div class="line">CGPoint pointB = CGPointMake(x1 + r1, y1);</div><div class="line">CGPoint pointC = CGPointMake(x2 - r2, y2);</div><div class="line">CGPoint pointD = CGPointMake(x2 + r2, y2);</div><div class="line">CGPoint pointC1 = CGPointMake(x1, y1 + (self.defaultTranslationY &gt; 0 ? 1 : -1 )*(fabs(y2 - y1)/2.f));</div><div class="line"></div><div class="line">[path moveToPoint:pointA];</div><div class="line">[path addQuadCurveToPoint:pointC controlPoint:pointC1];</div><div class="line">[path addLineToPoint:pointD];</div><div class="line">[path addQuadCurveToPoint:pointB controlPoint:pointC1];</div><div class="line">[path addLineToPoint:pointA];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DYHCircle</code>是一个单纯的模型，表示屏幕上的一个圆。按照设计图，一个个做这些坐标计算其实非常简单，另外引申一下，你还可以为这个模型加入角度的因素，不过是为这些坐标加入一些角度因子而已，类似的粘连问题最终都是用类似的模型解决的。</p>
<p>解决了粘连部分的贝塞尔曲线，我们可以在<code>-displayLinkAction:</code>中绘制了，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)displayLinkAction:(CADisplayLink *)displayLink</div><div class="line">&#123;</div><div class="line">[self drawLiquidToPushedView:self.pushedView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)drawLiquidToPushedView:(DYHLiquidView *)pushedView</div><div class="line">&#123;	</div><div class="line">//每一帧刷新时去绘制粘连部分</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">...</div><div class="line">//画连接部分</div><div class="line">BOOL successDraw = [self drawLiquidFromCircle:selfCircle toCircle:pushedCircle onPath:path];</div><div class="line"></div><div class="line">//刷新cashapeLayer</div><div class="line">if (successDraw) &#123;</div><div class="line">...</div><div class="line">self.shapeLayer.path = path.CGPath;</div><div class="line">if (fabs(selfCenter.y-pushedCenter.y) &gt; 0.99 * fabs(self.defaultTranslationY)) &#123;</div><div class="line">[self.shapeLayer removeFromSuperlayer];</div><div class="line">self.shapeLayer = nil;</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们使用了一个<code>CAShapeLayer</code>，再把已经准备好的贝塞尔曲线赋值给它，让它自动地把粘连部分渲染出来。</p>
<p>另外一个值得注意的点是我用到了<code>self.pushedView.layer.presentationLayer</code>，在iOS中，除了我们经常用到的<code>Layer</code>树(就是我们用<code>addSubLayer</code>等函数操作的那棵树)，另外还有<strong>呈现树</strong>。呈现树通过<code>Layer</code>树中所有<code>Layer</code>的<code>presentationLayer</code>所形成。注意<code>presentationLayer</code>仅仅当<code>Layer</code>首次被<em>提交</em>（就是第一次在屏幕上显示）的时候创建，所以在那之前调用<code>-presentationLayer</code>将会返回<code>nil</code>。</p>
<blockquote>
<p>当你改变一个<code>Layer</code>的属性，属性值的确是立刻更新的（如果你读取该属性的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。这是因为你设置的属性并没有直接调整<code>Layer</code>的外观，相反，他只是定义了动画结束之后的外观。</p>
<p>引用自<a href="https://zsisme.gitbooks.io/ios-/content/index.html" target="_blank" rel="external">iOS核心动画高级技巧</a></p>
</blockquote>
<p>屏幕上显示的事实上是<code>presentationLayer</code>，它的属性值是真正与屏幕上看到的保持一致的，所以，为了知道小球在屏幕上的实时位置，我使用了被”吐出”的小球的<code>presentationLayer</code>，用于绘制粘连部分。</p>
<p>到这里，一个可以以粘连效果“吐出”小球的控件的核心功能就完成了。</p>
<p>我还为它添加了”回收”操作，就是一段很简单的位移动画，你可以自行查阅源码。</p>
<p>完成控件后，连续做几次“吐出”操作，最终效果如下：</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo03_01.gif" alt=""></p>
<p>和原图还是有一定出入的，但是我觉得<strong>用贝塞尔曲线动态绘制不规则图形</strong>这个核心论点算是勉强达标了，这是一种常用的思路，不止是这种粘连效果，任何不规则的图形变化都可以考虑用这种方式。</p>
<h2 id="1-4-提交按钮"><a href="#1-4-提交按钮" class="headerlink" title="1.4. 提交按钮"></a>1.4. 提交按钮</h2><p><img src="http://op08ijx76.bkt.clouddn.com/animation1_SubmitButtonByColinGarvenOnDribbble.gif" alt=""></p>
<p><strong>引用自<a href="https://dribbble.com/shots/1426764-Submit-Button" target="_blank" rel="external">Submit Button</a></strong></p>
<p>这个按钮的动画也是Dribbble上非常流行的风格，在这一节里面我们尝试模仿这个按钮。核心点有两个：<strong>基于贝塞尔曲线的strokePath动画</strong>、<strong>做动画的分拆思想</strong>。</p>
<p>这个动画乍一看非常复杂，事实上并不需要用什么黑科技或者深奥的算法，我们只需要第一章回忆过的基础的<code>Core Animation</code> 知识，通过各种基本动画的组合 ，以及合理的参数调节，我们就能较为完整地实现这段动画。</p>
<p>首先我们需要分析这个动画，和上一节做的一样，<code>实现一个复杂的动画首先要拆解它的过程</code>，经过仔细观察这个gif，这个动画最后可拆解为四个大步骤，并且每个步骤中还有一些额外的动画：</p>
<ol>
<li>收缩为一个圆（收缩的同时，文字消失，用于做进度动画的Layer出现）</li>
<li>圆形进度动画</li>
<li>恢复形状（恢复原状的过程中勾勾出现，背景变绿）</li>
<li>恢复样式（勾勾消失，文字恢复，背景恢复）</li>
</ol>
<p>Demo地址<a href="https://github.com/DreamerDyh/DYHAnimationDemos" target="_blank" rel="external">DYHAnimationDemos</a>，选择Demo4-提交按钮。</p>
<p>我们一步一步的来实现这个动画，首先是收缩为一个圆的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[UIView animateWithDuration:0.1 animations:^&#123;</div><div class="line">self.titleLabel.alpha = 0.f;</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">if (finished) &#123;</div><div class="line">[UIView animateWithDuration:0.5f delay:0 usingSpringWithDamping:0.7f initialSpringVelocity:0.f options:0 animations:^&#123;</div><div class="line">self.bounds = CGRectMake(0, 0, self.originalBounds.size.height, self.originalBounds.size.height);</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">if (finished) &#123;</div><div class="line">[self doProgressAnimation];</div><div class="line">&#125;</div><div class="line">&#125;];</div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>首先用一个最基本的UIView动画使文字消失，再在文字完全消失时刻跟上一个改变bounds的动画，这一步非常简单，但有一个小tip:如果让想让一个正方形变成圆形，那么你所要做的就是把<code>cornerRadius</code> 这个值变成边长的 1/2，这一部分我们应用了这个简单的tip，具体的请去代码里面看。</p>
<p>接下来是第二步，圆形进度动画的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)doProgressAnimation</div><div class="line">&#123;</div><div class="line">//borderWidth置0(动画过渡)</div><div class="line">self.layer.borderWidth = 0.f;</div><div class="line">[self.layer addAnimation:[self borderWidthAnimationFrom:kBorderWidth] forKey:nil];</div><div class="line">...</div><div class="line">//progressBackLayer出现 (动画过渡)</div><div class="line">self.progressBackLayer.opacity = 1.f;</div><div class="line">[self.progressBackLayer addAnimation:[self opacityAnimationFrom:0] forKey:nil];</div><div class="line">//progressBar出现并立即开始转动</div><div class="line">self.progressShapeLayer.opacity = 1.f;</div><div class="line">CABasicAnimation* progressAnimation = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">...</div><div class="line">progressAnimation.fromValue = @(0);</div><div class="line">progressAnimation.toValue = @(1);</div><div class="line">...</div><div class="line">[self.progressShapeLayer addAnimation:progressAnimation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>borderWidth</code>置0是因为在实际实现过程中发现自身的border盖在了添加的进度<code>Layer</code>之上，所以使用了一段动画平滑地将自身的<code>borderWidth</code>置0。然后我们用到了<code>UIBezierPath</code>，创建一个在自身中心的圆形path，并用我们的得力工具<code>CAShapeLayer</code>渲染出了一个背景环和进度环，如果上一节的粘连效果你已理解透彻，这对你来说不成问题。最后我们为进度环添加了一段<code>strokeEnd</code>从0到1的动画，这个属性是做这类线条动画的核心，是<code>CAShapeLayer</code>所特有的，是一个介于0到1的浮点数，决定了<code>CAShapeLayer</code>沿着path的正方向渲染百分之多少。</p>
<p>你可能注意到我设置了<code>progressAnimation</code>的delegate，这是为了利用<code>&lt;CAAnimationDelegate&gt;</code>协议中的方法监听这个动画的结束，<code>Core Animaition</code>没有提供像<code>UIView</code>中的动画API那样可以用block回调的方便形式，而是提供了这样的一套代理方法让我们监听动画。另外的一个小技巧是利用KV机制，为animation设置一个name，方便我们确定动画的唯一性。</p>
<p>进度动画执行完成后，下一步是恢复形状：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">if (flag &amp;&amp; [[anim valueForKey:kAnimationName] isEqualToString:kAnimationNameProgress]) &#123;</div><div class="line">//干掉progressBack和shape</div><div class="line">self.progressBackLayer.opacity = 0.f;</div><div class="line">self.progressShapeLayer.opacity = 0.f;</div><div class="line">//恢复borderWidth</div><div class="line">self.layer.borderWidth = kBorderWidth;</div><div class="line">//设置backgroundColor</div><div class="line">self.backgroundColor = DYHAnimateSubmitButtonColor;</div><div class="line"></div><div class="line">//显示勾勾的同时恢复形状</div><div class="line">[UIView animateWithDuration:0.4f delay:0.1f usingSpringWithDamping:0.7f initialSpringVelocity:0.f options:0 animations:^&#123;</div><div class="line">self.bounds = self.originalBounds;</div><div class="line">&#125; completion:nil];</div><div class="line"></div><div class="line">[UIView animateWithDuration:0.7f animations:^&#123;</div><div class="line">self.finishIconImageView.alpha = 1.f;</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">if (finished) &#123;</div><div class="line">//恢复label</div><div class="line">self.titleLabel.alpha = 1.f;</div><div class="line">[UIView animateWithDuration:0.3f animations:^&#123;</div><div class="line">self.backgroundColor = [UIColor clearColor];</div><div class="line">self.finishIconImageView.alpha = 0.f;</div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">...</div><div class="line">&#125;];</div><div class="line">&#125;</div><div class="line">&#125;];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过两个简单的UIView动画并列调用，在恢复形状的过程中同时显示勾勾，这两个动作完成后，恢复label的显示，再次调用一个UIView动画恢复背景颜色，去掉勾勾，全部过程完成。</p>
<p>最终的效果如图所示：</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo04_01.gif" alt=""></p>
<p>大概达到了90%的效果，再次重申，这个例子的核心点有两个：<strong>基于贝塞尔曲线的strokePath动画</strong>、<strong>做动画时的分拆思想</strong>，希望你有所收获。</p>
<h2 id="1-5-线条动画"><a href="#1-5-线条动画" class="headerlink" title="1.5. 线条动画"></a>1.5. 线条动画</h2><p><img src="http://op08ijx76.bkt.clouddn.com/animation1_helloByDwiAsharialdyHambaliOnDribbble.gif" alt=""></p>
<p><strong>引用自<a href="https://dribbble.com/shots/3002765-hello" target="_blank" rel="external">hello!</a></strong></p>
<p>线条动画也是移动端非常常见的动画，如上图所示，这种类型的动画的通用实现方案其实就是上一节我们使用过的基于<strong>贝塞尔曲线的strokePath动画</strong>，从技术的角度来说，如果你掌握了上一节，这样的动画你已经可以轻松实现，但是，还有一个问题需要解决，如何绘制出像上图<strong>“hello”</strong>这样的线条呢？对于简单规则的path如圆形、矩形，很容易就能绘制出来，但是，如果要绘制如上图<strong>“hello”</strong>这样的贝塞尔曲线，单纯靠大脑想象是很难做到的，我们需要工具。</p>
<p>几乎所有设计工具都提供贝塞尔曲线的功能， 你可以选择你喜欢的任何一个，因为重要的东西不是工具，而是思想。我个人喜欢使用<strong>sketch</strong>来帮助我实现特定曲线，这是个专门为移动端设计而生的工具，它在我的日常工作中表现十分出色。</p>
<p>我首先截取了一张<strong>“hello”</strong>的静态图像，然后在<strong>sketch</strong>中创建了一张<strong>375px*667px</strong>的画布（与4.7英寸iPhone的1x屏幕分辨率一致，这也是移动端UI设计师最常用的画布），然后将”hello”图像挪到合适的位置，如图所示。</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo05_01.png" alt=""></p>
<p>接下来我开始使用<strong>sketch</strong>提供的贝塞尔曲线工具，创建沿着<strong>“hello”</strong>轨迹的路径，即用一条贝塞尔曲线去临摹<strong>“hello”</strong>，具体的创建方法请参考你所使用的设计工具的教程，这通常非常简单，按照1.1节所描述的贝塞尔曲线原理操作即可。</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo05_02.png" alt=""></p>
<p>经过反复微调，最终我们沿着图像得到了如下的路径，我们再调整一下<code>lineWidth</code>和<code>lineCap</code>，在sketch中，我们临摹出来的<strong>“hello”</strong>看起来效果不错，基本符合预期。</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo05_04.png" alt=""></p>
<p>接下来就是在代码实现的部分了，Demo地址<a href="https://github.com/DreamerDyh/DYHAnimationDemos" target="_blank" rel="external">DYHAnimationDemos</a>，选择Demo5-hello动画。</p>
<p>我们还是先使用我们的老朋友<code>UIBezierPath</code>来创建贝塞尔曲线，关键点和控制点的坐标可以很容易获取，因为我们在<strong>sketch</strong>中的的画布已经是4.7英寸iPhone的屏幕分辨率了，所以，我们只需要直接使用<strong>sketch</strong>内显示的点坐标即可（<strong>sketch</strong>的坐标系和iOS坐标系一致，以屏幕左上角为原点），如果你使用的设计软件不是<strong>sketch</strong>，你可能还需要转换一下这些数值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (UIBezierPath *)helloBezierPath</div><div class="line">&#123;</div><div class="line">if (!_helloBezierPath) &#123;</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">//h前的额外部分</div><div class="line">[path moveToPoint:CGPointMake(47.5, 182)];</div><div class="line">[path addCurveToPoint:CGPointMake(94, 246.5) controlPoint1:CGPointMake(47.5, 182) controlPoint2:CGPointMake(55, 265.5)];</div><div class="line">...</div><div class="line">//o后面的额外部分</div><div class="line">[path addCurveToPoint:CGPointMake(279, 349) controlPoint1:CGPointMake(317, 201) controlPoint2:CGPointMake(313, 347)];</div><div class="line">_helloBezierPath = path;</div><div class="line">&#125;</div><div class="line">return _helloBezierPath;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些代码非常简单，仅仅是单纯的调用三阶贝塞尔曲线绘制API，值得注意的是除了<strong>“hello”</strong>的本体外，我还绘制了两部分，便于更好的模拟原始gif的效果。</p>
<p>创建好了path，只需要<code>CAShapeLayer</code>就能高效的渲染出<strong>“hello”</strong>了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (CAShapeLayer *)helloLayer</div><div class="line">&#123;</div><div class="line">if (!_helloLayer) &#123;</div><div class="line">CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">...</div><div class="line">shapeLayer.strokeStart = 0.09;</div><div class="line">shapeLayer.strokeEnd = 0.86;</div><div class="line">...</div><div class="line">_helloLayer = shapeLayer;</div><div class="line">&#125;</div><div class="line">return _helloLayer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有几个属性需要讲解一下，<code>lineCap</code>决定了绘制出的线条端点的形状，可以是方形，尖形，或者圆形；<code>lineJoin</code>和<code>lineCap</code>类似，但是<code>lineJoin</code>决定的是拐点的形状；<code>strokeStart</code>决定了从整个path的百分之多少开始渲染，此前的部分不会被渲染，其默认值为0，即从path的起点开始绘制；我们上一节就使用过的<code>strokeEnd</code>决定了到整个path的百分之多少停止渲染，此后的部分不会被渲染，其默认值为1，即渲染至path的终点。</p>
<p>这个例子中我们使用了非默认值的<code>strokeStart</code>和<code>strokeEnd</code>，目的是把额外的部分隐藏掉，方便动画的实现。</p>
<p>做完上面这两步，屏幕上已经出现了我们想要的<strong>“hello”</strong>，如图所示，它看起来不错，但动起来就更完美了。</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo05_05.png" alt=""></p>
<p>接下来，我们要让我们的<strong>“hello”</strong>动起来了，首先我们观察原gif，确定动画思路。</p>
<p>我个人最终确定的思路如下：</p>
<ol>
<li><code>strokeEnd</code>从0-&gt;0.86，同时<code>strokeStart</code>从0-&gt;0.09</li>
<li>停留2秒</li>
<li><code>strokeEnd</code>从0.86-&gt;1，同时<code>strokeStart</code>从0.09-&gt;1</li>
</ol>
<p>把复杂的动画分拆成了简单动画的组合，下面是最终的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (void)sayHello</div><div class="line">&#123;</div><div class="line">...</div><div class="line">CABasicAnimation* strokeEndAnimation = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">...</div><div class="line">strokeEndAnimation.duration = kAnimationLongDuration;</div><div class="line">strokeEndAnimation.fromValue = @(0);</div><div class="line">[self.helloLayer addAnimation:strokeEndAnimation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStart:(CAAnimation *)anim</div><div class="line">&#123;</div><div class="line">if ([[anim valueForKey:kAnimationName] isEqualToString:kAnimationNameStrokeEnd1]) &#123;</div><div class="line">CABasicAnimation* strokeStartAnimation = [CABasicAnimation animationWithKeyPath:@&quot;strokeStart&quot;];</div><div class="line">...</div><div class="line">strokeStartAnimation.fromValue = @(0);</div><div class="line">[self.helloLayer addAnimation:strokeStartAnimation forKey:nil];</div><div class="line">&#125; else if([[anim valueForKey:kAnimationName] isEqualToString:kAnimationNameStrokeEnd2]) &#123;</div><div class="line">CABasicAnimation* strokeStartAnimation2 = [CABasicAnimation animationWithKeyPath:@&quot;strokeStart&quot;];</div><div class="line">...</div><div class="line">strokeStartAnimation2.toValue = @(1);</div><div class="line">[self.helloLayer addAnimation:strokeStartAnimation2 forKey:nil];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">if (flag &amp;&amp; [[anim valueForKey:kAnimationName] isEqualToString:kAnimationNameStrokeStart1])&#123;</div><div class="line">CABasicAnimation* strokeEndAnimation2 = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">...</div><div class="line">strokeEndAnimation2.toValue = @(1);</div><div class="line">strokeEndAnimation2.beginTime = CACurrentMediaTime()+kShowingDelay;</div><div class="line">[self.helloLayer addAnimation:strokeEndAnimation2 forKey:nil];</div><div class="line">&#125; ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我再次使用了<code>&lt;CAAnimationDelegate&gt;</code>来控制动画的执行，执行顺序大概是这样的，点击按钮后<code>strokeEndAnimation</code>和<code>strokeStartAnimation</code>开始执行，对应思路中的第一步；<code>strokeStartAnimation</code>执行完成，停留2秒，这里是用<code>beginTime</code>属性实现的，对应思路中的第二步；最后，<code>strokeEndAnimation2</code>和<code>strokeStartAnimation2</code>开始执行，对应思路中的第三步。</p>
<p>最终运行的结果如下：</p>
<p><img src="http://op08ijx76.bkt.clouddn.com/animation1_demo05_06.gif" alt=""></p>
<p>结果还不赖，本节的重点是<strong>如何实现复杂贝塞尔曲线</strong>以及<strong>线条动画</strong>，希望你有所收获。</p>
</article></main></body></html>